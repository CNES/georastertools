#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
This module defines a rastertool named Hillshade which computes the hillshade
of a Digital Height Model corresponding to a given solar position (elevation and azimuth).
"""
import logging.config
import sys
from typing import List
from pathlib import Path
import numpy as np

import rasterio
import rioxarray
from rasterio.windows import Window

from eolab.rastertools import utils
from eolab.rastertools import Rastertool, Windowable
from eolab.rastertools.processing import algo
from eolab.rastertools.processing import RasterProcessing, compute_sliding
from eolab.rastertools.product import RasterProduct

_logger = logging.getLogger(__name__)


class Hillshade(Rastertool, Windowable):
    """Raster tool that computes the hillshades of a Digital Elevation / Surface / Height Model
    corresponding to a given solar position.

    The input image is a raster that contains the height of the points as pixel values.

    At a given position p, the Hillshade tool check if the point is in the hillshade generated by
    any other points in the direction of the sun. To achieve this goal, the algorithm computes the
    angle :math:`\\gamma`: :math:`\\tan \\frac{Height}{Distance}`::

                          _____
                        x|     |  ^
                    x    |     |  | Height (from Digital Model)
               x   __    |     |  |
      ____p_______|  |___|     |__v____________
          <-------------->
              Distance

    The point is in the hillshade of another one if :math:`\\gamma < elevation_{sun}`.
    To avoid testing too many points, the "radius" parameter defines the max distance of the pixel
    to test. The radius can be set by the user or automatically computed by the Hillshade tool. In
    this latter case, the radius is :math:`\\frac{\\Delta h}{\\tan{elevation_{sun}}}` where
    :math:`\\Delta h` is :math:`max - min` of the pixel values in the input raster.

    The output image is a mask where pixels corresponding to hillshades equal to 1.
    """

    def __init__(self, elevation: float, azimuth: float, resolution: float, radius: int = None):
        """ Constructor for the Hillshade class.

        Args:
            elevation (float):
                Elevation of the sun (in degrees), 0 is vertical top (zenith).
            azimuth (float):
                Azimuth of the sun (in degrees), measured clockwise from north.
            resolution (float):
                Resolution of a raster pixel (in meters).
            radius (int, optional):
                Maximum distance from the current point (in pixels) to consider
                for evaluating the hillshade. If None, the radius is calculated
                based on the data range.
        """
        super().__init__()
        self.with_windows()

        self._elevation = elevation
        self._azimuth = azimuth
        self._resolution = resolution
        self._radius = radius

    @property
    def elevation(self):
        """Return the elevation of the sun (in degrees)"""
        return self._elevation

    @property
    def azimuth(self):
        """Return the azimuth of the sun (in degrees)"""
        return self._azimuth

    @property
    def resolution(self):
        """Return the resolution of a raster pixel (in meter)"""
        return self._resolution

    @property
    def radius(self):
        """Return the maximum distance from current point (in pixels)
        for evaluating the maximum elevation angle"""
        return self._radius

    def process_file(self, inputfile: str) -> List[str]:
        """
        Compute hillshade for the input file.

        Args:
            inputfile (str):
                Input image file path to process.

        Returns:
            List[str]: A list containing the file path of the generated hillshade image.

        Raises:
            ValueError: If the input file contains more than one band or if the radius exceeds constraints.
        """
        _logger.info(f"Processing file {inputfile}")
        outdir = Path(self.outputdir)
        output_image = outdir.joinpath(f"{utils.get_basename(inputfile)}-hillshade.tif")

        # compute the radius from data range
        # radius represents the max distance of buildings that can create a hillshade
        # considering the sun elevation.

        with rioxarray.open_rasterio(inputfile, chunks=True) as src:
            if src.shape[0] != 1:
                _logger.exception(ValueError("Invalid input file, it must contain a single band."))
                sys.exit(1)
            data = src[0]
            if data.size and not np.isnan(data).all():
                wmax = np.nanmax(data)
                wmin = np.nanmin(data)

        delta = int((wmax - wmin) / self.resolution)
        optimal_radius = abs(int(delta / np.tan(np.radians(self.elevation))))

        if self.radius is None or optimal_radius <= self.radius:
            self._radius = optimal_radius
            _logger.info(f"Using optimal radius {self.radius} for hillshade computation")
        else:
            _logger.warning(f"The optimal radius value is {optimal_radius} exceeding {self.radius} threshold. "
                            f"Oversized radius affects computation time and so radius is set to {self.radius}. "
                            "Result may miss some shadow pixels.")

        # Configure the processing
        hillshade = RasterProcessing("hillshade", algo=algo.hillshade, dtype=np.int8, in_dtype=np.float32,
                                     nbits=1, compress='lzw', per_band_algo=True)
        hillshade.with_arguments({
            "elevation": None,
            "azimuth": None,
            "resolution": None,
            "radius": None,
            "pad_mode": None
        })
        # set the configuration of the raster processing
        hillshade_conf = {
            "elevation": self.elevation,
            "azimuth": self.azimuth,
            "resolution": self.resolution,
            "radius": self.radius,
            "pad_mode": self.pad_mode
        }
        hillshade.configure(hillshade_conf)

        # STEP 1: Prepare the input image so that it can be processed
        with RasterProduct(inputfile, vrt_outputdir=self.vrt_dir) as product:

            # STEP 2: apply hillshade
            outdir = Path(self.outputdir)
            output_image = outdir.joinpath(
                f"{utils.get_basename(inputfile)}-hillshade.tif")

            with rasterio.Env(GDAL_VRT_ENABLE_PYTHON=True):
                with product.open_xarray(chunks=True) as src:
                    # dtype and creation options of output data
                    dtype = hillshade.dtype or rasterio.float32
                    src = src.astype(dtype)

                    # Hillshade computing
                    output = hillshade.compute(src).astype(dtype)

                    ##Create the file and compute
                    output.rio.to_raster(output_image)

        return [output_image.as_posix()]
